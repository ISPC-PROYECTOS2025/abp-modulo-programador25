# üìò Evidencia 5 ‚Äì Dise√±o de Clases (Programaci√≥n I)

## üìå Diagrama de Clases (UML)

Clase Usuario
- id: int
- nombre: str
- dispositivos: List<Dispositivo>
+ registrar_dispositivo(dispositivo: Dispositivo): void
+ eliminar_dispositivo(nombre: str): void
+ obtener_dispositivo(nombre: str) -> Dispositivo

Clase Dispositivo
- id: int
- nombre: str
- tipo: str
- estado: bool   // True=encendido, False=apagado
+ encender(): void
+ apagar(): void
+ __str__(): str

Clase Automatizacion
- id: int
- nombre: str
- dispositivos: List<Dispositivo>
- hora_activacion: str
+ activar(): void
+ validar_dispositivos_registrados(usuario: Usuario) -> bool
+ __str__(): str

Clase GestorDispositivos
- usuario: Usuario
+ listar_dispositivos(): List<Dispositivo>
+ agregar_dispositivo(dispositivo: Dispositivo): void
+ eliminar_dispositivo(nombre: str): void
Principios de POO aplicados al dise√±o

Abstracci√≥n
Cada clase en el diagrama representa una abstracci√≥n de la realidad:
Usuario = persona que usa el sistema.
Dispositivo = aparato inteligente.
Automatizaci√≥n = rutina programada.
Solo se exponen atributos y m√©todos relevantes (encender, apagar), ocultando detalles internos.

Encapsulamiento
Los atributos (estado, tipo, nombre) se acceden mediante m√©todos (encender, apagar, etc.).
Se evita modificar los datos internos directamente, garantizando consistencia.

Herencia
Dispositivo funciona como clase base.
Subclases como Luz, Sensor o Cafetera heredar√≠an atributos y m√©todos comunes.
Ejemplo: todas heredan encender() y apagar(), pero una Luz puede tener ajustar_brillo().

Polimorfismo
Automatizaci√≥n puede recorrer su lista de dispositivos y ejecutar encender() en todos, sin importar de qu√© tipo sean.
Cada dispositivo responde con su propia implementaci√≥n: la luz se enciende, la cafetera empieza a calentar, el sensor activa su modo, etc.

